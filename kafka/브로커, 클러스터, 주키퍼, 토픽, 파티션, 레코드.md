### 카프카의 데이터 저장, 전송 흐름.
- 카프카(클러스터 서버)는 프로듀서로부터 데이터를 전달받으면 
- 카프카 브로커는 프로듀서가 요청한 토픽의 파티션에 데이터를 저장하고 
- 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터를 전달한다.

### 브로커란?
- 카프카 브로커는 카프카 클라이언트와 데이터를 주고받기 위해 사용하는 주체이자, 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션이다.
- 하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행된다.
- 카프카 브로커 서버 1대로도 기본 기능이 실행되지만, 데이터를 안전하게 보관하고 처리하기 위해 3대 이상의 브로커 서버를 1개의 클러스터로 묶어서 운영한다.

### 클러스터란?
- 여러 개의 브로커 서버를 하나로 묶은 서버가 클러스터이다.
- 카프카 클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 수행한다.

### 토픽이란?
- 토픽은 카프카에서 데이터를 구분하기 위해 사용하는 단위이다. 
- 토픽은 1개 이상의 파티션을 소유하고 있다.


### 파티션이란?
- 파티션에는 프로듀서가 보낸 데이터들이 저장되고, 이 데이터를 레코드라고 부른다.
- 파티션은 카프카의 병렬처리의 핵심으로써 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 매칭된다.
- 컨슈머는 처리량이 한정된 상황에서 많은 레코드를 병렬로 처리하는 가장 좋은 방법은 컨슈머의 개수를 늘려 스케일 아웃하는 것이다.
- 컨슈머 개수를 늘림과 동시에 파티션 개수도 늘리면 처리량이 증가하는 것을 볼 수 있다.

파티션은 추가만 가능한(append-only) 파일이다. 
그리고 이 각각의 메세지가 저장되는 위치를 오프셋이라고 한다.
파티션에 저장된 메세지는 Consumer가 읽어가더라도 삭제되지 않는다.

### 여러 파티션과 프로듀서
프로듀서는 라운드로빈 또는 (해쉬)키로 파티션을 선택한다.(이것은 알고리즘에 따라 다르다.)

컨슈머는 컨슈머 그룹에 속한다.
한 개의 파티션은 컨슈머 그룹의 한 개 컨슈머만 연결이 가능하다.
**(이로 인해 컨슈머 그룹 기준으로 파티션의 메세지가 순서대로 처리되는 것을 보장할 수 있게 된다.)**
- 즉, 컨슈머 그룹에 속한 컨슈머들은 다른 파티션을 공유할 수 없다.
- 한 컨슈머 그룹 기준으로 파티션의 메세지는 순서대로 처리한다.


### 레코드
- 레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성되어 있다.
- 프로듀서가 생성한 **레코드**가 브로커로 전송되면 **오프셋**과 **타임스탬프**가 지정되어 저장된다.
- 브로커에 한번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 생성된다.
- **타임스탬프는** 프로듀서에서 해당 레코드가 생성된 시점의 유닉스 타임이 설정된다. 다만 프로듀서가 레코드를 생성할 대 임의의 타임스탬프 값을 설정할 수 있고, 토픽 설정에 따라 브로커에 적재된 시간으로 설정될 수 있다는 점을 주의해야 한다.
- **메세지 키**는 메세지 값을 순서대로 처리하거나 메시지 값의 종류를 나타내기 위해 사용한다. 메세지 키를 사용하면 프로듀서가 토픽에 레코드를 전송할 때 메세지 키의 해시값을 토대로 파티션을 지정하게 된다. 즉, 동일한 메시지 키라면 동일 파티션에 들어가는 것이다. 하지만 어느 파티션에 지정될 지는 알 수 없고, 파티션 개수가 변경되면 메세지 키와 **파티션 매칭이 달라지게 되므로 주의해야 한다.**
- **메세지 값**에는 실질적으로 처리할 데이터가 들어 있다. 메시지 키와 메시지 값은 직렬화되어 브로커로 전송되기 때문에 컨슈머가 이용할 때는 직렬화한 형태와 동일한 형태로 역직렬화를 수행해야 한다.






